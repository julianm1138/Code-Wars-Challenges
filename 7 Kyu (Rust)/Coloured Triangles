A coloured triangle is created from a row of colours, each of which is red, green or blue. Successive rows, each containing one fewer colour than the last, are generated by considering the two touching colours in the previous row. If these colours are identical, the same colour is used in the new row. If they are different, the missing colour is used in the new row. This is continued until the final row, with only a single colour, is generated.


// We can solve this by running a loop and comparing adjacent colors. 
// If equal, return the current color, else return the missing color.
// exit the loop when there is only one color left. 

// We can separate logic using two helper functions, the first function will compare adjacent colors and the second will reduce the rows down to 1 color. 


fn triangle(row_str: &str) -> String {

    
let first_row: Vec<char> = row_str.chars().collect();       //convert to vector of characters so we can compare colors easily 
    
    
fn compare_colors(c1: char, c2: char) -> char {                // helper function to compare ajdacent colors 
    if c1 == c2 {
        c1  
    } else {
 ['R', 'G', 'B']
    .into_iter()
    .find(|&x| x != c1 && x != c2)
    .unwrap()       }

}

fn reduce_row(mut row: Vec<char>) -> char {                       // helper function to reduce the rows down to 1
    while row.len() > 1 {                                         // the loop
        row = row.windows(2).map(|pair| compare_colors(pair[0], pair[1])).collect();     //use windows(2) for two adjacent elements per row, map to transform the vector, and call compare_colors for each pair. 
    }
    row[0]
}

reduce_row(first_row).to_string()        // call the reduce row on the input row 

}

