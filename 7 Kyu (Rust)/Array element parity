In this Kata, you will be given an array of integers whose elements have both a negative and a positive value, except for one integer that is either only negative or only positive. Your task will be to find that integer.


// We can solve this by using a Hashset to check for positive and negative pairs (a mathcing pair will make the hashset empty) and only the duplicate positive or negative-only number will stay in the set.

use std::collections::HashSet;

fn solve(arr: &Vec<i32>) -> i32 {
    let mut set = HashSet::new();             // Make the hashset

    for &num in arr {                         // iterate vector slice
        if set.contains(&-num) {              // check if the negative version of the current number is in the hashset
            set.remove(&-num);                // if yes remove it
        } else {
            set.insert(num);                  // if not add it
        }
    }

      *set.iter().next().unwrap()          // return the only value left in the set 
}
