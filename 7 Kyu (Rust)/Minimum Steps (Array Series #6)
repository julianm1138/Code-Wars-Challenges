Task
Given an array of N integers, you have to find how many times you have to add up the smallest numbers in the array until their Sum becomes greater or equal to K.

// We can solve this by sorting nums and using a counter inside a while loop. 


fn minimum_steps(nums: &[i32], value: i32) -> usize {
    
    let mut vec = nums.to_vec();      // convert nums to vec for easy indexing
    vec.sort_unstable();
      
    let mut sum = vec[0] + vec[1];    // start at the sum of the first two numbers so we can add each following number to that sum on each iteration
    
    if sum > value {                 // handle cases where the sum is greater than the value 
        return 0 as usize
    } else if sum == value {         // handle cases where the sum == the value
        return 1 as usize
    }

    let mut counter = 1;             // start at 1 because we are considering sum to be the first count at this point
    let mut i = 2;                   // start at index 2 because we use the first two indexes in the sum's definition
    
   while sum < value {             
        sum += vec[i];           // add each number to the sum
        counter += 1;            // add to the counter on each iteration
        i += 1;                  // increment the index
    } 
      counter as usize  
    }


// the refactored version uses the index as the counter:

fn minimum_steps(nums: &[i32], value: i32) -> usize {
    let mut vec = nums.to_vec();
    vec.sort_unstable(); 

    let mut sum = 0;
    for (i, &num) in vec.iter().enumerate() {
        sum += num;
        if sum >= value {
            return i as usize;
        }
    }
}
